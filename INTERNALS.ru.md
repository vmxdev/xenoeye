# Внутреннее устройство

  * [Общие сведения](#общие-сведения)
  * [Рабочие и вспомогательные потоки](#рабочие-и-вспомогательные-потоки)
  * [Объекты мониторинга и фильтры](#объекты-мониторинга-и-фильтры)
  * [Как добавить в коллектор новое Netflow-поле](#)
  * [Источник времени](#источник-времени)
  * [Фиксированные временные окна](#фиксированные-временные-окна)
  * [Скользящие средние](#скользящие-средние)


### Общие сведения

При разработке коллектора мы пытались сделать так, чтобы он был:

  * Простым, насколько это возможно
  * С гибкими настройками
  * Достаточно производительным
  * Не очень требовательным к ресурсам, мог работать на относительно медленном железе или в виртуальных машинах

Значение производительности и экономии ресурсов иногда недооценивают. Ведь всегда можно увеличить частоту семплирования и тем самым уменьшить количество экспортируемых фловов в секунду.

Однако нужно принимать во внимание, что например при частоте семплирования 1:1000 вы не видите буквально 99.9% трафика. Чем выше частота, тем меньше точность отчетов и тем хуже видны аномалии в трафике.


### Рабочие и вспомогательные потоки

При старте коллектор читает общие конфиги и файлы `mo.conf`. Запускаются рабочие потоки и несколько вспомогательных:

  * Поток, который экспортирует агрегированные данные в файлы для СУБД
  * Поток, запускающий скрипты при превышении лимитов скользящих средних и при возврате трафика в норму
  * Поток, который делает дампы скользящих средних

Рабочие потоки принимают netflow и обрабатывают его.


### Объекты мониторинга и фильтры

После того, как коллектор прочитал конфигурационный файл `mo.conf`, он пытается скомпилировать фильтр объекта мониторинга в байткод. Если получается, байткод сохраняется в памяти.

Каждый приходящий флов декодируется, используя шаблоны. Для флова исполняется байткод фильтров, проверяется относится ли этот флов к объекту мониторинга.

Если относится, то из флова выделяются нужные поля и обрабатываются дальше — в окнах фикисрованного размера и скользящих средних.


### Как добавить в коллектор новое Netflow-поле

В Netflow v9 и IPFIX существуют и описаны несколько сотен полей. Коллектор из коробки поддерживает только самые распространенные. Поля некоторых типов можно достаточно просто добавить.

Коллектор оперирует netflow-полями двух видов. Первый вид — поля `IN_BYTES` и `IN_PKTS`. Эти поля "зашиты" в код как агрегируемые. Если они встречаются в массиве полей для экспорта, то данные из этих полей будут суммироваться.

Остальные поля считаются не-агрегируемыми.

Сейчас используется такой подход к описанию netflow-полей: они задаются в коде, в файлах [netflow.def](netflow.def) и [filter.def](filter.def).

При компиляции используется техника [https://en.wikipedia.org/wiki/X_Macro](X-Macro), список полей превращается в лестницу из условий `if () else if ()...`. С точки зрения производительности лучше не добавлять в эти файлы много полей, а обойтись только необходимым минимумом.

Возможно, позже мы переделаем архитектуру и можно будет добавить произвольное количество полей без потери производительности обработки.

Формат файлов такой:

`netflow.def`
``` c
FIELD(internal_id,            "Description",              FIELD_TYPE,      netflow_id,  min_size,  max_size)
```

  * `internal_id` — внутренний идентификатор, ожидается валидное имя для поля структуры C
  * `Description` — текстовое описание поля
  * `FIELD_TYPE` — тип поля (сейчас поддерживаются `NF_FIELD_INT`(целое) и `NF_FIELD_IP_ADDR`(IP адрес))
  * `netflow_record_id` — идентификатор поля
  * `min_size`, `max_size` — минимальный и максимальный размер поля в байтах

Данные о полях (идентификатор, размер и т.д.) можно взять из [NetFlow Version 9 Flow-Record Format - Cisco Systems](https://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html) или из [IP Flow Information Export (IPFIX) Entities](http://www.iana.org/assignments/ipfix/ipfix.xhtml)

Добавление поля в `netflow.def` изменит только парсер netflow. Чтобы использовать это поле в фильтрах и для экспорта в СУБД, нужно добавить его еще в `filter.def`

``` c
FIELD(ID,      "name",          TYPE,  src_netflow_field,   dst_netflow_field)
```

  * `ID` — внутренний идентификатор
  * `name` — строка, которая будет использоваться в фильтрах
  * `TYPE` — тип (сейчас поддерживается RANGE(диапазон целых), `ADDR4` и `ADDR6` - IP адреса)
  * `src_netflow_field`, `dst_netflow_field` — поля netflow с которыми нужно работать. То, что написано в `internal_id` из `netflow.def`. Если могут быть префиксы "источник" (`src`) и "назначение" `dst`, нужно указать соответствующие поля.

После изменения файлов программу нужно перекомпилировать.


### Источник времени

В каждом флове может быть время, когда роутер начал и когда закончил наблюдение за ним. Коллектор **не смотрит** на это время. Временем флова считается текущее время на сервере. Это немного уменьшает точность, но сильно упрощает обработку, особенно обработку скользящих средних.


### Фиксированные временные окна

Для экспорта в СУБД применяется классичская схема с двумя банками данных.

В начале активен первый банк, рабочий поток записывает в него данные.

После того как подошло время экспорта, вспомогательный поток атомарно переключает банки. Активным становится тот, который был неактивным и в него начинают писаться новые данные.

После переключения неактивный банк пересортировывается. Если в параметрах указано, что для экспорта нужно только N первых записей, то отбираются первые записи, остальные суммируются. Из результата формируется текстовый файл, который записывается на диск.

Вспомогательный поток ждет нужное время и процесс повторяется.


### Скользящие средние

В коллекторе используются [https://en.wikipedia.org/wiki/Moving_average#Cumulative_average](куммулятивные скользящие средние)

Значение байт или пакетов в скользящем окне пересчитывается при получении каждого нового флова по формуле:


$$N = N - \frac{\Delta t}{T}\cdot N + V$$


где N — количество байт/пакетов в скользящем окне

$\Delta t$ — разница между текущим временем и временем последнего обновления скользящей средней

T — размер скользящего окна

V — значение величины (количество байт/пакетов) в новом пришедшем флове

Для таких скользящих средних можно использовать временные окна почти произвольной длины. Не нужно хранить все фловы за промежуток времени. Нужно хранить только одну величину - количество байт или пакетов в окне.

Но если использовать очень большие окна и большой трафик, то можно потерять точность. В коллекторе есть возможность повысить точность "в лоб" - можно вместо машинного `double` использовать `__float128`.
Для этого нужно изменить значение `MAVG_TYPE` в файле [monit-objects.h](monit-objects.h)

