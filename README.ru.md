# xenoeye
Netflow collector and analyzer

[![Build Status](https://app.travis-ci.com/vmxdev/xenoeye.svg?branch=master)](https://app.travis-ci.com/vmxdev/xenoeye)

Программа находится в стадии планирования и разработки, используйте с осторожностью

Сейчас коллектор может захватывать Netflow, парсить фловы, фильтровать по заданным правилам, агрегировать данные по разным netflow-полям и экспортировать в СУБД для дальнейшего анализа и визуализации.


### Поддерживаемые протоколы:

  * Netflow v9
  * IPFIX


### Поддерживаемые netflow-поля

можно посмотреть в файле `netflow.def`.


### Фильтры

Фильтры задаются BPF-подобными правилами. Например, фильтр "`src net 1.2.3.4/28 and proto 17`" выберет только фловы с UDP-трафиком, идущим из сети `1.2.3.4/28`.
Текущий набор полей, по которым работает фильтрация, можно посмотреть в файле `filter.def`.


Если вы хотите добавить новое netflow-поле или поле фильтрации, смотрите ниже ("Пердолинг")


Коллектор может генерировать текстовые файлы для экспорта в СУБД. На данный момент поддерживается только PostgreSQL.


Визуализировать данные из СУБД можно с помощью Grafana.



### Сборка

Для минимальной установки Debian нужно доустановить такие пакеты:

```sh
$ sudo apt -y install git autoconf gcc make libpcap-dev
```

Клонируем репозиторий и инициализируем подмодули

```sh
$ git clone https://github.com/vmxdev/xenoeye
$ cd xenoeye
$ git submodule update --init --recursive
```

Собственно сборка

```sh
$ autoreconf -i
$ /configure --sysconfdir=/etc/xenoeye --localstatedir=/var/lib
$ make
```

После этого мы должны получить бинарный файл xenoeye

Опциональный шаг:

```sh
$ sudo make install
```

make install копирует бинарный файл xenoeye в /usr/local/bin, конфигурационные файлы xenoeye.conf и devices.conf в /etc/xenoeye и создает каталоги /var/lib/xenoeye/mo, /var/lib/xenoeye/exp и /var/lib/xenoeye/expfailed.

Каталог `/var/lib/xenoeye` должен быть доступен для записи процессу xenoeye

Все пути по умолчанию можно изменить, они задаются в конфигурационном файле `xenoeye.conf`. Конфигурационные файлы в `xenoeye` - это JSON, в которых разрешены комментарии.


### Настраиваем и тестируем получение netflow

`xenoeye` может принимать netflow двумя способами - обычным интерфейсом сокетов или с помощью pcap.

Второй способ больше подходит для тестов. Если у вас, например, есть .pcap-файлы с netflow-трафиком, вы можете проиграть их на loopback интерфейсе с помощью tcpreplay (`tcpreplay -i lo dump.pcap`) и отправить в коллектор.

За захват netflow отвечает секция "capture". Там перечислены сокеты, на которых коллектор будет слушать и pcap-интерфейсы c BPF-фильтрами.

Чтобы увидеть, что коллектор принимает и декодирует фловы, выставьте параметр "dump-flows" в секции "debug". Допускаются значения

  * "none" - фловы не логгируются
  * "syslog" - декодированные фловы передаются в syslog и дополнительно печатаются в stderr
  * "/path/to/file.txt" - фловы пишутся в файл

Запускаем коллектор
```sh
$ xenoeye
```

или 

```sh
$ xenoeye -c /path/to/xenoeye.conf
```

Если вы используете захват с помощью pcap, коллектор должен запускаться с правами суперпользователя

После того, как коллектор получит netflow-пакеты с шаблонами, он начнет их обрабатывать. Когда включена опция "dump-flows", можно увидеть фловы приблизительно в таком текстовом виде

```
IPv4 src addr: 1.2.3.4; IPv4 dst addr: 5.6.7.8; Src TOS: 0; Protocol: 6; Src port: 7878; Dst port: 8787; ICMP type: 0; Input SNMP index: 111; Src VLAN: 222; Src mask: 16; Dst mask: 24; Src AS: 12345; Dst AS: 0; IPv4 next hop: 0.0.0.0; TCP flags: 24; Output SNMP index: 333; Bytes: 65522; Packets: 185; Min TTL: 51; Max TTL: 52; Unknown field 152: 0x00 0x00 0x01 0x77 0x0d 0x0c 0x07 0x00 ; Unknown field 153: 0x00 0x00 0x01 0x77 0x0d 0x0c 0xee 0x00 ; Unknown field 136: 0x02 ; Unknown field 61: 0xff ; Unknown field 243: 0x00 0x00 ; Unknown field 245: 0x00 0x00 ; Unknown field 54: 0x00 0x00 0x00 0x00 ; *dev-ip: 9.10.11.12; *dev-id: 555500, *rate: 1 [flow_debug.c, ...]
```

Коллектор показывает все поля, которые есть в netflow-пакете. Часть полей он знает, часть не знает и показывает как "`Unknown field NNN`: <байты с данными>". Если хотите научить коллектор понимать новое netflow-поле, см. ниже ("Пердолинг").

Кроме полей netflow, коллектор показывает "виртуальные" поля со звездочкой: `*dev-ip: 1.2.3.4; *dev-id: 123456, *rate: 1`.

  * `dev-ip` - адрес сенсора
  * `dev-id` - идентификатор сенсора
  * `rate` - sampling rate, по умолчанию 1

### Установка sampling rate

Для установки частоты сэмплирования отредактируйте файл `devices.conf`. Это JSON-массив, каждый элемент - запись об устройстве-источнике netflow (роутере).

[
        {
                "ip": "1.2.3.4",
                "id": 123456,
                "sampling-rate": 10000
        },
        {
                "ip": "2.3.4.5",
                "sampling-rate": 1000
        }
]

Частоту можно установить для IP адреса устройства и, если нужно, то и для source ID (его можно увидеть в текстовом дампе флова, виртуальное поле `*dev-id`. Коллектор показывает частоту сэмплирования в каждом флове, в виртуальном поле `*rate`.

Внутри коллектора частота семплирования - это просто коэффициент, на который умножается количество октетов и пакетов.

### Объекты мониторинга

После того, как убедились в том что netflow приходит и парсится, можно создать и настроить объекты мониторинга.

Каталог объектов мониторинга задается в главном конфигурационном файле, параметр `mo-dir`. По умолчанию это `/var/lib/xenoeye/mo`.

Чтобы создать объект мониторинга, создайте подкаталог с именем этого объекта.

```sh
$ mkdir -p /var/lib/xenoeye/mo/test
```

И создайте там файл с описанием объекта мониторинга. Файл должен называться `mo.conf` и имеет такую структуру:

```
{
	/* В объекте UDP трафик из сети 10.11.12.0/24 */
	"filter": "src net 10.11.12.0/24 and proto udp",

	"debug": {
		/* Для теста можно включить отладочный режим. Фловы, которые принадлежат этому объекту, будут печататься в syslog и stderr */
		"dump-flows": "syslog"
	},

	/* Окна фиксированной длительности */
	"fwm": [
		{
			"name": "rep1",
			"fields": ["packets desc", "octets desc", "src host"],
			"time": 10,     /* размер окна в секундах, по умолчанию 30 сек */
			"limit": 5      /* ограничение количества строк экспорта */
		},
		{
			"name": "rep2",
			"fields": ["octets desc", "proto"]
		}
	]
}
```

Фильтр отбирает только те фловы, которые нужны для мониторинга по конкретному объекту. Список полей, по которым можно фильтровать фловы, находится в файле `filter.def`. Чтобы добавить новое поле, см. ниже ("Пердолинг")

В фильтре могут использоваться виртуальные поля `*dev-ip` и `*dev-id`. Например, фильтр "dst net 10.11.12.0/24 and dev-ip 1.2.3.4" отберет только фловы, которые приходят с роутера 1.2.3.4.

В секции `fwm` описываются фиксированные временные окна. Коллектор агрегирует информацию за время `time` (если время не указано, используется 30 секунд) и сбрасывает данные в виде текстового SQL-скрипта. Каталог для экспорта по умолчанию `/var/lib/xenoeye/exp`. Его можно изменить в `xenoeye.conf`, параметр `export-dir`.

При агрегации используются netflow-поля, указанные как параметр "fields". Поля "packets", "octets" и "bits" считаются как сумма пакетов, байт или бит при уникальных остальных полях. `bits` = `octets` * 8.

Например, `"fields": ["dst host", "packets"]` посчитает все уникальные хосты назначения и сумму пакетов по ним.

`["dst host", "proto", "octets"]` - посчитает уникальные хост+протокол и сумму байт для каждой комбинации хост+протокол.

По умолчанию данные будут отсортированы в порядке возрастания.

Для набора полей `["dst host", "proto", "octets"]` результат может быть таким, например:

```
IP        Proto    Octets
1.2.3.4   6        200
1.2.3.4   17       100
1.2.3.5   1        300
1.2.4.1   6        150
...
```

Если вы не хотите экспортировать все записи (их может быть очень много), можно воспользоваться параметром "limit". Он задает количество строк, которые будут экспортироваться. Последней строкой будет идти строка с суммой остальных. В полях, которые не агрегируются, будет NULL, в полях с пакетами/байтами будет сумма. Например:

```
IP        Proto    Octets
1.2.3.4   6        200
1.2.3.4   17       100
1.2.3.5   1        300
NULL      NULL     1500
...
```

В случае, если вы используете лимит, порядок строк экспорта становится важен. Если нужно экспортировать top-5 src IP по количеству пакетов, то поля задаются так: `"fields": ["packets desc", "src host"]`.

Квалификатор `desc` указывает, что сортировать нужно в обратном порядке, от больших к меньшим

### Файлы экспорта и загрузка в СУБД

Коллектор генерирует файлы экспорта в виде SQL-сриптов для PostgreSQL. В каталоге экспорта (по умолчанию '/var/lib/xenoeye/exp') cоздаются файлы такого вида:


``` sql
create table if not exists "monit_object1_rep1" (
  time TIMESTAMPTZ,
  proto int,
  dst_net inet,
  octets int);

create index concurrently if not exists "monit_object1_rep1_idx" on "monit_object1_rep1"(time);

insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  6 ,  '1.2.3.4' ,  2719 );
insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  17 ,  '2.3.4.5' ,  10352 );
insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  1 ,  '3.4.5.6' ,  1584 );
insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  6 ,  '4.5.6.7' ,  75165 );
```

Имя таблицы состоит из имени каталога объекта наблюдения (`monit_object1`) и имени окна (`rep1`).

Для экспорта в СУБД нужно эти файлы периодически отдавать утилите `psql`.

В каталоге `scripts/` находится файл `fill-db.sh`, который это и делает. Измените в нем параметры подключения (`user:password@127.0.0.1:5432/database`) и опционально пути к каталогам. База данных должна существовать, пользователь должен иметь права на запись.

  * `EXP_DIR` - каталог, в котором скрипт ищет файлы экспорта
  * `FAIL_DIR` - каталог, куда скрипт складывает файлы если экспорт закончился неудачей (нет подключения к СУБД или что-то еще пошло не так)

Скрипт можно запускать из командной строки (в бесконечном цикле `while true; do ./fill-db.sh ; sleep 10; done`) или из крона.


### Визуализация с помощью Grafana

(TBW)


### Пердолинг

Добавление netflow-полей и полей для фильтров

Поля netflow, которые знает коллектор, находятся в файле `netflow.def`. Формат записи:

``` c
FIELD(internal_id,            "Description",              FIELD_TYPE,      netflow_id,  min_size,  max_size)
```

  * `internal_id` - внутренний идентификатор, ожидается валидное имя для поля С-структуры
  * `Description` - строка с описанием поля
  * `FIELD_TYPE` - тип поля (поддерживаются поля `NF_FIELD_INT`(целое число) и `NF_FIELD_IP_ADDR`(IP-адрес) )
  * `netflow_record_id` - идентификатор поля
  * `min_size`,  `max_size` - минимальный и максимальный размер поля в байтах

Данные для полей можно брать из [NetFlow Version 9 Flow-Record Format - Cisco Systems](https://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html) или из [IP Flow Information Export (IPFIX) Entities](http://www.iana.org/assignments/ipfix/ipfix.xhtml)

Добавление поля в `netflow.def` изменяет только парсер netflow-пакетов. Для того, чтобы это поле можно было использовать в фильтрах и в полях для экспорта, нужно добавить его еще в `filter.def`

``` c
FIELD(ID,      "name",          TYPE,  src_netflow_field,   dst_netflow_field)
```

  * `ID` - внутренний идентификатор
  * `name` - строка с полем, которое будет использоваться в фильтрах
  * `TYPE` - тип (поддерживаются RANGE(диапазон целых), `ADDR4` и `ADDR6` - IP-адреса)
  * `src_netflow_field`,  `dst_netflow_field` - netflow-поля, по которым будет работать этот фильтр. Допускаются значения `internal_id` из `netflow.def`. Если в фильтре может быть префикс `src` и `dst`, будут использоваться соответствующие netflow-поля.
