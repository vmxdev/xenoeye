
# Пошаговая инструкция по установке и настойке коллектора

  * [Сборка и установка](#build-install)
  * [Проверяем получение Netflow](#getting-netflow)
  * [Распределение нагрузки по нескольким CPU]()
  * [Частота семплирования]()
  * [Объекты мониторинга]()
  * [IP-списки]()
  * [Настраиваем окна фиксированного размера]()
  * [Экспорт в СУБД]()
  * [Простые отчеты по IP-адресам]()
  * [Можно ли использовать GeoIP?]()
  * [Определяем спам-ботов и ssh-сканеры]()
  * [Строим графики с помощью gnuplot]()
  * [Графики с помощью Python Matplotlib]()
  * [Визуализация трафика в Grafana]()
  * [Скользящие средние]()
  * [Настройка и установка порогов]()
  * [Скрипты и их параметры]()
  * [Расширенная статистика]()
  * [Оповещение об аномалиях с помощью Telegram-робота]()

<a name="build-install"/>
### Сборка и установка <a name="build-install"></a>

На минимальной установке Debian нужно доустановить такие пакеты:

```sh
$ sudo apt -y install git autoconf gcc make libpcap-dev
```

Клонируем репозиторий и инициализируем подмодули

```sh
$ git clone --recurse-submodules https://github.com/vmxdev/xenoeye
```

Или

```sh
$ git clone https://github.com/vmxdev/xenoeye
$ cd xenoeye
$ git submodule update --init --recursive
```

Собственно сборка

```sh
$ autoreconf -i
$ ./configure --sysconfdir=/etc/xenoeye --localstatedir=/var/lib
$ make
```

После этого мы должны получить бинарный файл `xenoeye`


### Установка

```sh
$ sudo make install
```

`make install` копирует бинарный файл xenoeye в /usr/local/bin, конфигурационные файлы xenoeye.conf и devices.conf в /etc/xenoeye и создает каталоги /var/lib/xenoeye/mo, /var/lib/xenoeye/exp и /var/lib/xenoeye/expfailed.

Каталог `/var/lib/xenoeye` должен быть доступен для записи процессу xenoeye


Это опциональный шаг, коллектор можно запускать из произвольного места

Все пути по умолчанию можно изменить, они задаются в конфигурационном файле `xenoeye.conf`. Конфигурационные файлы в `xenoeye` - это JSON, в которых разрешены комментарии.


### Проверяем получение Netflow <a name="getting-netflow"></a>

Коллектор может принимать Netflow двумя способами - обычным интерфейсом сокетов или захватывать с помощью pcap.

Второй способ больше подходит для тестов. Если у вас, например, есть .pcap-файлы с Netflow-трафиком, вы можете проиграть их на loopback интерфейсе с помощью tcpreplay (`tcpreplay -i lo dump.pcap`) и таким способом отправить данные в коллектор.

За захват Netflow отвечает секция "capture" главного конфигурационного файла (`xenoeye.conf`). Там перечислены сокеты, на которых коллектор будет слушать и pcap-интерфейсы c BPF-фильтрами.

Чтобы увидеть, что коллектор принимает и декодирует фловы, выставьте параметр "dump-flows" в секции "debug". Допускаются значения

  * "none" - фловы не логгируются, обычное состояние системы
  * "syslog" - декодированные фловы передаются в syslog и дополнительно печатаются в stderr
  * "/path/to/file.txt" - фловы в текстовом виде пишутся в файл

Запускаем коллектор

```sh
$ xenoeye
```

или 

```sh
$ xenoeye -c /path/to/xenoeye.conf
```

Если вы используете захват с помощью pcap, коллектор должен запускаться с правами суперпользователя

После того, как коллектор получит Netflow-пакеты с шаблонами, он сможет парсить фловы с данными. Когда включена опция "dump-flows", можно увидеть фловы приблизительно в таком текстовом виде:

```
IPv4 src addr: 1.2.3.4; IPv4 dst addr: 5.6.7.8; Src TOS: 0; Protocol: 6; Src port: 7878; Dst port: 8787; ICMP type: 0; Input SNMP index: 111; Src VLAN: 222; Src mask: 16; Dst mask: 24; Src AS: 12345; Dst AS: 0; IPv4 next hop: 0.0.0.0; TCP flags: 24; Output SNMP index: 333; Bytes: 65522; Packets: 185; Min TTL: 51; Max TTL: 52; Unknown field 152: 0x00 0x00 0x01 0x77 0x0d 0x0c 0x07 0x00 ; Unknown field 153: 0x00 0x00 0x01 0x77 0x0d 0x0c 0xee 0x00 ; Unknown field 136: 0x02 ; Unknown field 61: 0xff ; Unknown field 243: 0x00 0x00 ; Unknown field 245: 0x00 0x00 ; Unknown field 54: 0x00 0x00 0x00 0x00 ; *dev-ip: 9.10.11.12; *dev-id: 555500, *rate: 1 [flow_debug.c, ...]
```

Коллектор показывает все поля, которые есть в netflow-пакете. Часть полей он может не знать и показывает их как "`Unknown field NNN: <байты с данными>`".

Кроме полей Netflow, коллектор показывает "виртуальные" поля со звездочкой: `*dev-ip: 1.2.3.4; *dev-id: 123456, *rate: 1`.

  * `dev-ip` - IP-адрес сенсора (роутера)
  * `dev-id` - идентификатор сенсора
  * `rate` - sampling rate, по умолчанию 1

### Распределение нагрузки по нескольким CPU

В коллекторе используется такая модель распределения нагрузки: каждая запись в секции "capture" - это отдельный рабочий поток.

Вы можете запустить коллектор на нескольких UDP-портах и подавать на каждый порт Neflow разных роутеров.


### Частота семплирования

Коллектор не берет (по крайней мере сейчас) частоту сэмплирования из options template.

Для установки частоты сэмплирования отредактируйте файл `/etc/xenoeye/devices.conf`. Это JSON-массив, каждый элемент - запись об устройстве-источнике Netflow (роутере).

``` json
[
        {
                "ip": "1.2.3.4",
                "id": 123456,
                "sampling-rate": 10000
        },
        {
                "ip": "2.3.4.5",
                "sampling-rate": 1000
        }
]
```

Частоту можно установить для IP адреса устройства и, если нужно, то и для source ID (его можно увидеть в текстовом дампе флова, виртуальное поле `*dev-id`). Коллектор показывает частоту сэмплирования в каждом флове, в виртуальном поле `*rate`.

Внутри коллектора частота семплирования - это просто коэффициент, на который умножается количество октетов и пакетов.


### Объекты мониторинга

Объект мониторинга - это основная сущность в коллекторе. К объектам мониторинга привязаны отчеты и скользящие средние.

Объект мониторинга задается фильтром с BPF-подобным синтаксисом.

Например, фильтр `dst net 10.11.12.0/24` выделяет весь трафик, который идет в сеть `10.11.12.0/24`.

Фильтры могут определять не только сети, но и произвольные объекты, которые можно выделить из Netflow

Объект мониторинга `src net 10.11.12.0/24 and proto tcp and dst port 80 or 443` определяет TCP-трафик, который выходит из сети 10.11.12.0/24 на порты 80 или 443, то есть исходящий HTTP/HTTPS-трафик.

В фильтрах допускаются скобки, операторы `and`, `or` и `not`. Список полей, которые разрешены в фильтрах, можно посмотреть в файле `filter.def`

Физически объект мониторинга это каталог с файлом `mo.conf`, расположеный в специальном месте - каталоге объектов мониторинга.

Каталог объектов мониторинга задается в главном конфигурационном файле, параметр `mo-dir`. По умолчанию это `/var/lib/xenoeye/mo`.

Чтобы создать объект мониторинга c именем `ingress`, создайте подкаталог с таким названием.

```sh
$ mkdir -p /var/lib/xenoeye/mo/ingress
```

И в этом каталоге создайте файл `mo.conf` с таким содержимым:

``` json
{
	"filter": "dst net 10.11.12.0/24",

	"debug": {
		/* Для теста включаем отладочный режим. Фловы, которые принадлежат этому объекту, будут печататься в syslog и stderr */
		"dump-flows": "syslog"
	}
}
```

``` json
{
	/* В объекте трафик на сеть 10.11.12.0/24 */
	"filter": "dst net 10.11.12.0/24",

	"debug": {
		/* Для теста можно включить отладочный режим. Фловы, которые принадлежат этому объекту, будут печататься в syslog и stderr */
		"dump-flows": "syslog"
	},

	/* Определяем несколько окон фиксированной длительности */
	"fwm": [
		{
			/* окно только с количеством байт */
			"name": "total",
			"fields": ["octets"]
		},
		{
			/* в окне собираются номера протокола и количество байт по каждому протоколу */
			"name": "by_proto",
			"fields": ["octets", "proto"]
		},
		{
			/* src IP адрес и количество пакетов с каждого уникального IP */
			"name": "packets_by_src",
			"fields": ["packets desc", "src host"],
			"limit": 5      /* ограничим количество строк экспорта */
		},
		{
			/* IP адрес, порт назначения и количество пакетов для каждого уникального src IP + dst порт */
			"name": "octets_by_src_and_port",
			"fields": ["octets desc", "src host", "dst port"],
			"limit": 5,
			"time": 10     /* устанавливаем размер окна в 10 секунд (по умолчанию 30 сек) */
		}
	]
}
```

### Фильтры

Объекты задаются фильтрами. Фильтры - это BPF-подобные правила. В качестве элементов для фильтрации можно использовать различные поля netflow.
Фильтр отбирает только те фловы, которые нужны для мониторинга по конкретному объекту.


Например, объект с фильтром "`src net 1.2.3.4/28 and proto 17`" выберет только фловы с UDP-трафиком, идущим из сети `1.2.3.4/28`.
В фильтрах допускаются логические операторы `or`, `and`, `not` и скобки.

Список полей, по которым можно фильтровать фловы, находится в файле [`filter.def`](filter.def). Чтобы добавить новое поле, см. ниже ("Добавление полей")

Поля бывают двух типов - адреса или числовые. Для выбора адреса можно использовать сеть в CIDR-нотации или название списка сетей.
Числовые поля задаются одним числом или диапазоном через `-`.

Для полей, которые могут иметь направление, можно указывать `src` или `dst`.


В фильтре могут использоваться виртуальные поля `dev-ip` и `dev-id`. Например, фильтр "`dst net 10.11.12.0/24 and dev-ip 1.2.3.4`" отберет только фловы, которые приходят с роутера 1.2.3.4.

### Списки IP-сетей

В полях с IP адресами сети можно задавать цифровыми значениями (`1.2.3.4/24`) или именем списка. Для создания списка сетей создайте файл в каталоге `/var/lib/xenoeye/iplists/`. Имя файла и будет именем списка. Например, можно создать файл `/var/lib/xenoeye/iplists/bogon-net` и поместить в него bogon-сети, по одной сети на строку:
```
10.0.0.0/8
100.64.0.0/10
127.0.0.0/8
169.254.0.0/16
172.16.0.0/12
192.0.0.0/24
192.0.2.0/24
192.168.0.0/16
198.18.0.0/15
198.51.100.0/24
203.0.113.0/24
224.0.0.0/4
240.0.0.0/4
255.255.255.255/32
```

После этого в фильтре можно будет указывать bogon-net в качестве сети.

Фильтр "`net bogon-net`" отберет фловы, в которых `IPV4_SRC_ADDR` **или** `IPV4_DST_ADDR` принадлежат bogon-сетям.

Фильтр "`src net bogon-net and dst net bogon-net`" отберет фловы, в которых и `IPV4_SRC_ADDR` **и** `IPV4_DST_ADDR` относятся к bogon-сетям.

### Окна фиксированной длительности

В секции `fwm` описываются фиксированные временные окна. Коллектор агрегирует информацию за время `time` (если время не указано, используется 30 секунд) и по истечении этого времени сбрасывает данные в виде текстового SQL-скрипта. Каталог для экспорта по умолчанию `/var/lib/xenoeye/exp`. Его можно изменить в `xenoeye.conf`, параметр `export-dir`.

При агрегации используются netflow-поля, указанные как параметр "fields". Поля "packets", "octets" и "bits" считаются как сумма пакетов, байт или бит при уникальных остальных полях. `bits` = `octets` * 8.

Например, `"fields": ["octets"]` посчитает сумму байт за окно для всего объекта мониторинга.

`["octets", "proto"]` - посчитает все протоколы и сумму байт для каждого протокола.

По умолчанию данные в файле дампа будут отсортированы в порядке возрастания.

Если вы не хотите экспортировать все записи (их может быть очень много), можно воспользоваться параметром "limit". Он задает количество строк, которые будут экспортироваться. Последней строкой будет идти строка с суммой остальных строк, не попавших в дамп. В полях последней строки, которые не агрегируются, будет NULL, в полях с пакетами/байтами будет сумма всех не попавших данных. Например:

```
IP        Proto    Octets
1.2.3.4   6        200
1.2.3.4   17       100
1.2.3.5   1        300
NULL      NULL     1500
...
```

В случае, если вы используете лимит, порядок строк экспорта становится важен. Если нужно экспортировать top-5 src IP по количеству пакетов, то поля задаются в таком порядке: `"fields": ["packets desc", "src host"]`. Сначала идет поле с пакетами (строки будут отсортированы по нему), потом остальные поля.

Квалификатор `desc` указывает, что сортировать нужно в обратном порядке, от больших значений к меньшим.


### Файлы экспорта и загрузка в СУБД

Коллектор генерирует файлы экспорта в виде SQL-сриптов для PostgreSQL. В каталоге экспорта (по умолчанию '/var/lib/xenoeye/exp') cоздаются файлы такого вида:


``` sql
create table if not exists "monit_object1_rep1" (
  time TIMESTAMPTZ,
  proto int,
  dst_net inet,
  octets int);

create index concurrently if not exists "monit_object1_rep1_idx" on "monit_object1_rep1"(time);

insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  6 ,  '1.2.3.4' ,  2719 );
insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  17 ,  '2.3.4.5' ,  10352 );
insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  1 ,  '3.4.5.6' ,  1584 );
insert into "monit_object1_rep1" values ( to_timestamp(1639725910),  6 ,  '4.5.6.7' ,  75165 );
```

Имя таблицы состоит из имени каталога объекта наблюдения (`monit_object1`), символа подчеркивания (`_`) и имени окна (`rep1`).

Для экспорта в СУБД можно эти файлы периодически отдавать утилите `psql`.

В каталоге `scripts/` находится файл `fill-db.sh`, который это и делает. Измените в нем параметры подключения (`user:password@127.0.0.1:5432/database`) и опционально пути к каталогам. База данных должна существовать, пользователь должен иметь права на запись.

  * `EXP_DIR` - каталог, в котором скрипт ищет файлы экспорта
  * `FAIL_DIR` - каталог, куда скрипт складывает файлы если экспорт закончился неудачей (нет подключения к СУБД или что-то еще пошло не так)

Скрипт можно запускать из командной строки (в бесконечном цикле `while true; do ./fill-db.sh ; sleep 10; done`) или из крона.

### Установка и настройка PostgreSQL на одном сервере с коллектором

``` sh
$ sudo apt -y install postgresql
#
$ sudo su - postgres -c "createuser -P xenoeye"
Enter password for new role:
Enter it again:
$ sudo su - postgres -c "createdb xenoeyedb"
$ sudo su - postgres -c "psql -d xenoeyedb -c 'GRANT ALL PRIVILEGES ON DATABASE xenoeyedb TO xenoeye;'"
```

``` sh
$ vi scripts/fill-db.sh
```

Редактируем параметры подключения:
  `psql postgresql://user:password@127.0.0.1:5432/database -f "$sqlscript"`

заменяем на

  `psql postgresql://xenoeye:password@localhost/xenoeyedb -f "$sqlscript"`

### Визуализация с помощью Grafana

Данные о трафике из таблиц PostgreSQL можно визуализировать с помощью [grafana](https://grafana.com/).

Для этого подключите источник данных PostgreSQL.

![Grafana PostgreSQL data source](docs-img/pg-data-source.png?raw=true "Grafana PostgreSQL data source")

Создайте дашбоард и добавляйте к нему панели с графиками.


Простой график с общим трафиком по объекту мониторинга:

![Grafana chart 1](docs-img/grafana-1.png?raw=true "Grafana chart 1")

SQL-запрос для такого графика:

``` sql
SELECT
  time AS "time",
  octets
FROM ingress_all
WHERE
  $__timeFilter(time)
ORDER BY 1
```

График с разбивкой по IP-адресам назначения:

![Grafana chart 2](docs-img/grafana-2.png?raw=true "Grafana chart 2")

SQL-запрос для графиков такого типа:

```
SELECT
  time AS "time",
  sum(octets) AS ip,
  COALESCE (src_host::text, 'Other') as ips
FROM ingress_bytes_by_src
WHERE
  $__timeFilter(time)
GROUP BY time, ips
ORDER BY time, ip
```

Еще несколько примеров графиков:


![Grafana chart 3](docs-img/grafana-3.png?raw=true "Grafana chart 3")

![Grafana chart 4](docs-img/grafana-4.png?raw=true "Grafana chart 4")

![Grafana chart 5](docs-img/grafana-5.png?raw=true "Grafana chart 5")

![Grafana chart 6](docs-img/grafana-6.png?raw=true "Grafana chart 6")


